#! /usr/bin/env bash
# --------------------------------------------------------------------
#                               SOURCE
# --------------------------------------------------------------------
# https://arslan.io/2019/07/03/how-to-write-idempotent-bash-scripts/
# https://timvisee.com/blog/elegant-bash-conditionals/

# simple if-statements

if [ expression ]
then
    command
fi
# or
if [ expression ]; then command; fi

# control operators

&& # the AND operator, run the following command only if previous succeeded
|| # the OR operator, run the following command only if previous failed

# exit codes
# The exit code is normally hidden. The status of the last run command is stored in the ? variable. You may inspect it by invoking

echo $?

# Imagine you want to source the ~/.profile file, but only if it is readable

if [ -r ~/.profile ]; then
    source ~/.profile
fi

# We can simplify this using control operators

[ -r ~/.profile ] && . ~/.profile

cat ~/.profile && echo This is your profile || echo Failed to read profile
init && configure && install && cleanup || echo Install failed

# A function or script returns the exit code of the last expression

test -f "FILE" && source "$_" || echo "$_ does not exist" >&2

# job control

# The fg command moves a background job into the foreground.
# The bg command moves a suspended foreground job into the background.
# The jobs command shows the current list of jobs.
# The kill command can kill jobs or send signals to them.
# The disown command removes a job from the list of jobs (without killing it).
# A foreground job can be suspended by typing ^Z (Control-Z). A suspended job is temporarily stopped

# --------------------------------------------------------------------
# -e - Exit immediately if any command fails.
# -u - Exit if an unset variable is invoked.
# -o pipefail - Exit if a command in a piped series of commands fails.

set -euo pipefail

# Never use mkdir directly, instead use it with the-p flag. This flag make sure mkdir won’t error if the directory exists

mkdir -p mydir

# We create symbolic links with the following command
# The -f flag removes the target destination before creating the symbolic link, hence it’ll always succeed.

ln -sfn source target

# delete file/files. Use the -f flag which ignores non-existent files.

rm -f example.txt

# Modifying a file
# Here the -q means silent mode and -F enables fixed string mode. Grep will silently fail if /mnt/dev doesn’t exist so the echo statement will never be called.
# If this is run again, you’ll end up having duplicate entries in your /etc/fstab. One way of making this idempotent is to make sure to check for certain placeholders via grep

if ! grep -qF "/mnt/dev" /etc/fstab; then
  echo "/dev/sda1 /mnt/dev ext4 defaults 0 0" | sudo tee -a /etc/fstab
fi

# Check if variable, file or dir exists

echo "complex set of rules" > /etc/conf/foo.txt

# Calculating the text might be an expensive operation, hence you don’t want to write it every time you call the script. 
# To make it idempotent you check if the file exists via the -f flag of the inbuilt test property of the shell:

if [ ! -f "/etc/conf/foo.txt" ]; then
 echo "complex set of rules" > /etc/conf/foo.txt
fi

# Here -f is just an example, there are many other flags you can use, such:
# -d: directory
# -z: string of zero length
# -p: pipe
# -x: file and has execute permission

# install 1password CLI

if ! [ -x "$(command -v op)" ]; then
  export OP_VERSION="v0.5.6-003"
  curl -sS -o 1password.zip https://cache.agilebits.com/dist/1P/op/pkg/${OP_VERSION}/op_linux_amd64_${OP_VERSION}.zip
  unzip 1password.zip op -d /usr/local/bin
  rm -f 1password.zip
fi

# Formatting a device
# To format a volume, say with an ext4 format, you can use a command like the following
# This command prints attributes for a given block device. 
# Hence prepending basically means to proceed with formatting only when blkid fails, which is an indication that the given volume is not formatted yet.

blkid "$VOLUME_NAME" || mkfs.ext4 "$VOLUME_NAME"

# Mounting a device
# Trying to mount a volume to an existing directory can be done with the following example command
# One way is to check the output of mount command and see if the volume is already mounted. But there is a better way to do it. Using the mountpoint command

if ! mountpoint -q "$DATA_DIR"; then
  mount -o discard,defaults,noatime "$VOLUME_NAME" "$DATA_DIR"
fi

# --------------------------------------------------------------------
# Getting system information
# This will show the uptime, CPU temperature, current CPU frequency, battery status and RAM usage. 
# The various commands used will differ somewhat between platforms and distributions.
# .bash_aliases

alias inf="uname -sr && uptime| sed 's/ //' && sensors|grep Pack && \
           lscpu|grep 'CPU MHz:' && acpi && \
           echo -n 'Memory in use: ' && free -m|grep Mem|\
           awk '{print \$3+\$5\" megs\"}'"
           
# Listing directories

alias lsd="ls -d */"

# --------------------------------------------------------------------

# ShellCheck - A shell script static analysis tool
# source: https://github.com/koalaman/shellcheck#installing

shellcheck name_script

# Use tar to dump the archive directly into SSH and un-tar it at the other

tar cf - 100k | ssh joe@10.1.0.1:/destination/ "tar -x" 

# VI

# i or a - editing
# ^ - Go to beginning of line
# $ - Go to end of line
# w - Go to next word
# b - Go to previous word
# e - Move to the end of the previous word
# r - e - Replace current character by another (ex: e)
# x - Delete current character
# d - b - Delete previous word
# d - w - Delete next word
# v - Edit the current command in your text editor
# u - Undo previous action(s)
